-------------------------------------------------------------------------------
-- Description:
--  Implements a testbench that instantiates the DDS Compiler for testing.
--  The input data is taken from a set of test vectors generated by 
--  the py_scripts/dds_model.ipynb notebook file included in this directories.  
--  The DDS module output values are compared against the set of golden test 
--  vectors also generated by the Python script
-------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;
USE ieee.math_real.ALL;

ENTITY dds_bank_tb IS
  GENERIC (
            DESIGN_ROOT_DIR : string := "."
          );
end dds_bank_tb;

ARCHITECTURE behavior OF dds_bank_tb IS 

  -- Clock period definitions
  constant ACLK_PERIOD : time := 4 ns;

--  -- Function for phase increment calculation from desirable frequency
--  -- Here assuming sample clock is 250 MHz
--  --
--  function phase_incr (des_freq : std_logic_vector) return std_logic_vector is
--    variable tmp : std_logic_vector(47 downto 0) := (others => '0');
--  begin
--    tmp := (des_freq * ACLK_PERIOD) sla 16;
--    phase_incr <= tmp /  2500000000;
--    return tmp(G1'high downto G1'low);
--  end function;


  -- Component Declaration for the Transmit Module
    COMPONENT ddsb IS
    GENERIC (
      NCH : INTEGER;
      AXIS_TDATA_WIDTH : INTEGER
    );
    PORT (
      aclk : IN STD_LOGIC;
      aresetn : IN STD_LOGIC;
      s_axis_phase_tvalid : IN STD_LOGIC;
      s_axis_phase_tdata : IN STD_LOGIC_VECTOR(191 DOWNTO 0);
      m_axis_data_tvalid : OUT STD_LOGIC;
      m_axis_data_tdata : OUT STD_LOGIC_VECTOR(383 DOWNTO 0)
    );
  END COMPONENT ddsb;

  -- Inputs
  signal aclk               : std_logic := '0';
  --signal s_axis_data_tvalid : std_logic := '0';
  --signal m_axis_data_tready : std_logic := '0';

  -- Outputs
  signal real_out, imag_out : std_logic_vector(16-1 downto 0):=(others=>'0');
  signal valid_out                 : std_logic := '0';

  -- Internal
  --signal read_source_data : std_logic:='0';
  --signal write_dest_data  : std_logic:='0';
  signal read_source_data_reg, read_source_data_next : std_logic;
  signal s_tvalid_reg, s_tvalid_next : std_logic;

  signal sim_end       : boolean := false;
  signal file_end      : boolean;
  signal reset_shreg   : std_logic_vector(3 downto 0) := (others => '0');
  signal reset_s       : std_logic := '0';
  signal tx_data_out   : std_logic_vector(32-1 downto 0);
  --signal tready_sig    : std_logic := '0';

  signal s_axis_tdata : std_logic_vector(15 downto 0) := (others => '0');
  --signal s_axis_tvalid: std_logic := '0';
  signal s_axis_tlast : std_logic := '0';

  signal m_axis_0_tdata : std_logic_vector(15 downto 0);
  signal m_axis_0_tvalid: std_logic;

  signal m_axis_1_tdata : std_logic_vector(15 downto 0);
  signal m_axis_1_tvalid: std_logic;

  signal m_axis_2_tdata : std_logic_vector(15 downto 0);
  signal m_axis_2_tvalid: std_logic;

  signal s_axis_tready: std_logic;
  signal axis_tready_2: std_logic;
  signal axis_tready_3: std_logic;
  signal m_axis_tready: std_logic;
  signal phase_reg, phase_next : unsigned(15 downto 0);

begin

  -----------------------------------------------------------------------------
  -- Clock generation process
  aclk_process :process
  begin
    aclk <= '0';
    wait for ACLK_PERIOD/2;
    aclk <= '1';
    wait for ACLK_PERIOD/2;
  end process;

  -----------------------------------------------------------------------------
  -- Reset generation
  startup_reset_gen_p: process(aclk)
  begin
    if (rising_edge(aclk)) then
      reset_shreg <= reset_shreg(reset_shreg'left-1 downto 0) & '1';
      reset_s     <= reset_shreg(reset_shreg'left);
    end if;
  end process;

  -----------------------------------------------------------------------------
  -- Phase generation
  phase_gen_p: process(aclk)
  begin
    if rising_edge(aclk) then
      if reset_s = '0' then
        phase_reg <= (others => '0');
      else
        phase_reg <= phase_next;
      end if;
    end if;
  end process;

  --next state logic
  -- el numero que coloco aca lo obtengo de la funcion phase_incr
  phase_next <= phase_reg + to_unsigned(9059, 16) when s_tvalid_reg = '1' else phase_reg;

  -----------------------------------------------------------------------------
  -- DUT instances
  dut_0: dds
  port map (
             aclk          => aclk,
             aresetn       => reset_s,

             s_axis_phase_tvalid => s_tvalid_reg,
             s_axis_phase_tdata  => std_logic_vector(phase_reg), --s_axis_phase_tdata'length)), --s_phase_tdata_reg,
             m_axis_data_tvalid  => valid_out, --m_axis_2_tvalid,
             m_axis_data_tdata   => tx_data_out --m_axis_2_tdata
           );
   U0 : ddsb
    GENERIC MAP (
      NCH => 12,
      AXIS_TDATA_WIDTH => 16
    )
    PORT MAP (
      aclk => aclk,
      aresetn => aresetn,
      s_axis_phase_tvalid => s_axis_phase_tvalid,
      s_axis_phase_tdata => s_axis_phase_tdata,
      m_axis_data_tvalid => m_axis_data_tvalid,
      m_axis_data_tdata => m_axis_data_tdata
    );

  real_out <= tx_data_out(16-1 downto 0);
  imag_out <= tx_data_out(32-1 downto 16);

  -----------------------------------------------------------------------------
  -- Data sources
--  i_source_real: entity work.read_dat_file
--  generic map (
--                C_FILENAME    => "../../../../../files/dds_input.txt",
--                C_FRACT_WIDTH => 0)
--  port map (
--             clk            => aclk,
--             enable         => read_source_data_reg, --read_source_data_reg,
--             sim_finished   => sim_end,
--             data           => s_axis_tdata,
--             file_finished  => file_end);
--
  -----------------------------------------------------------------------------
  -- Data outputs
  i_sink_real: entity work.write_data_file
  generic map (
                C_FILENAME    => "../../../../../files/dds_real_out.txt",
                C_FRACT_WIDTH => 15)
  port map (
             clk            => aclk,
             enable         => valid_out, --m_axis_2_tvalid, --write_dest_data,
             sim_finished   => sim_end,
             data           => real_out); --m_axis_2_tdata);

  i_sink_imag: entity work.write_data_file
  generic map (
                C_FILENAME    => "../../../../../files/dds_imag_out.txt",
                C_FRACT_WIDTH => 15)
  port map (
             clk            => aclk,
             enable         => valid_out, --m_axis_2_tvalid, --write_dest_data,
             sim_finished   => sim_end,
             data           => imag_out);

  -----------------------------------------------------------------------------
  -- Generate control signals, input/output flow control
  process(aclk)
  begin
    if rising_edge(aclk) then
      if reset_s = '0' then
        read_source_data_reg <= '0';
        s_tvalid_reg <= '0';
      else
        read_source_data_reg <= read_source_data_next;
        s_tvalid_reg <= s_tvalid_next;
      end if;
    end if;
  end process;

  --next state logic
  --read_source_data_next <= '1' when s_axis_tready = '1' else '0';
  read_source_data_next <= '1' when reset_s = '1' else '0';
  s_tvalid_next <= '1' when read_source_data_reg = '1' else '0';

  i_stim: process
  begin		
    -- hold reset state for 100 ns.
    wait for 100 ns;	

    wait for ACLK_PERIOD*10;

    --tready_sig <= '1';

    -- Keep looping until no source test vectors remain
    while not file_end loop
      wait for ACLK_PERIOD;
    end loop;

    wait for ACLK_PERIOD;

    report "*** SIMULATION COMPLETED !!! ***" severity failure;

    wait;
  end process;

--write_dest_data <= valid_out and tready_sig;

end;
